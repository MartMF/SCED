-- when you add another property, you have to edit the onSave, the .json file with the LuaScriptState
-- and the part when you send the current data to re-create the elements, that is, the 
-- 'manipulate data and then respawn'

local PlayermatApi     = require("playermat/PlayermatApi")
local MythosAreaApi    = require("mythos/MythosAreaApi")
local SearchLib        = require("util/SearchLib")



local PHASE_NAMES = {
  "I. Mythos Phase",
  "II. Investigation Phase",
  "III. Enemy Phase",
  "IV. Upkeep Phase"
}
local PHASE_IMAGES = {
  "https://steamusercontent-a.akamaihd.net/ugc/933819604050849085/9E22AFD7B0157140FC177DBCCBCB1D61D6A0329F/",
  "https://steamusercontent-a.akamaihd.net/ugc/933819604050885611/845B5AA915F30492B5F34864698B9C3627FA5763/",
  "https://steamusercontent-a.akamaihd.net/ugc/982233321870235122/492996D07ABF6DDA4B605A3013C4892839DCF1F3/",
  "https://steamusercontent-a.akamaihd.net/ugc/982233321870237261/C287CAED2423970F33E72D6C7415CBEC6794C533/"
}

function onSave()
  return JSON.encode({
    phaseId = phaseId,
    broadcastChange = broadcastChange,
    broadcastChangeVerbosity = broadcastChangeVerbosity,
    pingMythos = pingMythos
  })
end

function loadFromSaveTable(savedData)
  for var, val in pairs(JSON.decode(savedData)) do
    _G[var] = val
  end
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    loadFromSaveTable(savedData)
  else
    phaseId = 1
    broadcastChange = false
    broadcastChangeVerbosity = false
    pingMythos = false
    end

  self.createButton({
    tooltip        = "change phase",
    click_function = "changeState",
    function_owner = self,
    width          = 600,
    height         = 600,
    matColor          = { r = 0, g = 0, b = 0, a = 0 }
  })

  log('PhaseTracker loaded with phaseId ' .. phaseId ..
      ', broadcastChange ' .. tostring(broadcastChange) ..
      ', broadcastChangeVerbosity ' .. tostring(broadcastChangeVerbosity) ..
      ', pingMythos ' .. tostring(pingMythos))
  self.addContextMenuItem("Toggle Broadcasting", updateBroadcast)
  self.addContextMenuItem("Toggle Verbosity Broadcasting", updateBroadcastVerbosity)
  self.addContextMenuItem("Toggle Ping Mythos Area", togglePing)

  -- detect player mats
  local mats = {}
  table.insert(mats, getObjectByName('Playermat 1: White'))
  table.insert(mats, getObjectByName('Playermat 2: Orange'))
  table.insert(mats, getObjectByName('Playermat 3: Green'))
  table.insert(mats, getObjectByName('Playermat 4: Red'))
  log('Found ' .. size(mats) .. ' player mats')
end

function updateBroadcast(playerColor)
  -- Changes (toggles) the if the phase changes are broadcast or not
  Player[playerColor].clearSelectedObjects()
  for _, tracker in ipairs(getObjectsWithTag("LinkedPhaseTracker")) do
    tracker.setVar("broadcastChange", not broadcastChange)
    if not broadcastChange then
      -- If broadcastChange is off, broadcastChangeVerbosity and pingMythos should also be off
      tracker.setVar("broadcastChangeVerbosity", false)
      tracker.setVar("pingMythos", false)
    end
  end
  broadcastToAll("Broadcasting phase changes has been " .. (broadcastChange and "enabled." or "disabled."))
end

function updateBroadcastVerbosity(playerColor)
  -- Changes (toggles) the if the phase changes are broadcast with a lot of verbosity or not
  Player[playerColor].clearSelectedObjects()
  for _, tracker in ipairs(getObjectsWithTag("LinkedPhaseTracker")) do
    tracker.setVar("broadcastChangeVerbosity", not broadcastChangeVerbosity) -- Toggle  → Set the opposite
    if broadcastChangeVerbosity then
      -- If broadcastChangeVerbosity is on, broadcastChange should also be on
      tracker.setVar("broadcastChange", true)
    end
  end
broadcastToAll("Broadcasting phase changes in (Verbosity mode) has been " .. (broadcastChangeVerbosity and "enabled." or "disabled."))
end

function togglePing(playerColor)
  -- Changes (toggles)
  Player[playerColor].clearSelectedObjects()
  for _, tracker in ipairs(getObjectsWithTag("LinkedPhaseTracker")) do
    tracker.setVar("pingMythos", not pingMythos) -- Toggle  → Set the opposite
    if pingMythos then
      -- If pingMythos is on, broadcastChangeVerbosity and broadcastChange should also be on
      tracker.setVar("broadcastChange", true)
      tracker.setVar("broadcastChangeVerbosity", true)
    end
  end
  broadcastToAll("Broadcasting phase changes in (Verbosity mode) has been " ..
  (broadcastChangeVerbosity and "enabled" or "disabled") .. 'and the Phase Tracker will bring you to the Mythos Area.')
end

function changeState(_, player_clicker_color, isRightClick)
  -- get newId for all trackers
  local newId = phaseId + (isRightClick and -1 or 1)
  if newId == 0 then
    newId = 4
  elseif newId == 5 then
    newId = 1
  end

  -- broadcast if option is enabled
  if broadcastChange and not broadcastChangeVerbosity then
    broadcastToAll(PHASE_NAMES[newId])
  elseif broadcastChangeVerbosity then
    expressChangeWithVerbosity(newId)
    if pingMythos and newId == 1 then
      pingMythosPhase(player_clicker_color)
    elseif pingMythos and newId == 2 then
      print(_)
      print(player_clicker_color)
      print(isRightClick)
      pingPlayerMiniCards(player_clicker_color)
    end
  end 

  -- 
  local data = self.getData()
  data["CustomImage"]["ImageURL"] = PHASE_IMAGES[newId]
  data["CustomImage"]["ImageSecondaryURL"] = PHASE_IMAGES[newId]
  data["LuaScriptState"] = "{\"broadcastChange\":" ..
      tostring(broadcastChange) ..
      ",\"phaseId\":" .. newId ..
      ",\"broadcastChangeVerbosity\":" ..
      tostring(broadcastChangeVerbosity) .. 
      ",\"pingMythos\":" ..
      tostring(pingMythos) ..
      "}"
    
  -- update all trackers with tag
  for i, tracker in ipairs(getObjectsWithTag("LinkedPhaseTracker")) do
    local pos = tracker.getPosition()
    local rot = tracker.getRotation()
    local scale = tracker.getScale()
    tracker.destruct()
    spawnObjectData({ -- Esto es una funcion de tts
      data     = data,
      position = pos,
      rotation = rot,
      scale    = scale
    })
  end
end

-- Added

function expressChangeWithVerbosity(newId)
  -- This function shows every change in the Phase tracker
  -- And some events related to the game

  -- Load data of the Agenda Card
  dmd = getDoomMetadata()
  amd = getActMetadata()
  if type(dmd) ~= "table" then
    local a = 1 / 0 -- Force error  
  end

  -- Acording to the phase and Agenda, show some messages
  if newId == 1 then
    broadcastToAll('End of the round')
    broadcastEndOfPhaseEffects(dmd.id, 4)
    broadcastToAll('Mythos Phase begins', {r=1, g=0, b=0})
    broadcastStartOfPhaseEffects(dmd.id, 1, {r = 1, g = 0, b = 0})
    
  elseif newId == 2 then
    broadcastToAll('End of Mythos Phase', {r=1, g=0, b=0})
    broadcastEndOfPhaseEffects(amd.id, 1, { r = 1, g = 0, b = 0 })
    broadcastToAll('Investigation Phase begins.', {r=1, g=1, b=0})
    broadcastStartOfPhaseEffects(amd.id, 2, {r = 1, g = 1, b = 0})
    showHandResourceInfo({ r = 1, g = 1, b = 0 })
    
  elseif newId == 3 then
    broadcastToAll('End of Investigation Phase', {r=1, g=1, b=0})
    broadcastEndOfPhaseEffects(dmd.id, 2, { r = 1, g = 1, b = 0 })
    broadcastToAll('Enemy Phase begins.', {r=0, g=1, b=0})
    broadcastStartOfPhaseEffects(dmd.id, 3, { r = 0, g = 1, b = 0 })

  elseif newId == 4 then
    broadcastToAll('End of Enemy Phase', {r=0, g=1, b=0})
    broadcastEndOfPhaseEffects(dmd.id, 3)
    broadcastToAll('Upkeep Phase begins.', {r=1, g=1, b=0})
    broadcastStartOfPhaseEffects(dmd.id, 4, { r = 0, g = 1, b = 0 })
  end
end

function pingMythosPhase(player_clicker_color)
  pl = getPlayer(player_clicker_color)
  all = getObjects()
  for _, obj in ipairs(all) do
    if obj.name == 'Doom Counter' or obj.getName() == 'Doom Counter' then
      pos = obj.getPosition()
      pl.pingTable(pos)
      pl.lookAt({position=pos, pitch= 80, yaw=90})
    end
  end
end

function pingPlayerMiniCards(player_clicker_color)
  log('pingPlayerMiniCards')
  all = getObjects()
  pl = getPlayer(player_clicker_color)
  found = 0
  for _, obj in ipairs(all) do
    if obj.type == 'Card' then
      if string.find(obj.getGMNotes(), 'Minicard') or obj.hasTag('Minicard') then
        pos = obj.getPosition()
        pl.pingTable(pos)
        found = found + 1
        if found == 1 then pl.lookAt({position=pos, pitch= 80, yaw=90}) end -- Look at one of them
      end
    end
  end
end

function showHandResourceInfo(color)
  color = color or { r = 1, g = 1, b = 1 }
  -- This shows how many cards and resources has every MatPlayer
  local matColors = Player.getAvailableColors()
  for _, matColor in ipairs(matColors) do
    local player = Player[matColor]
    local cards = player.getHandObjects(1)
    local num = #cards
    local resources = PlayermatApi.getCounterValue(matColor, "ResourceCounter")
    printToAll(matColor .. ' has ' .. num .. ' cards in hand and ' .. resources .. ' resources.', color)
  end
end


-- Tables with info about effects

local endOfPhaseEffects = {
  ["01107"] = {
    [3] = { message = "Agenda: Forced - At the end of the enemy phase: Each unengaged Ghoul enemy moves 1 location towards the Parlor." },
    [4] = { message = "Agenda: Forced - At the end of the round: Place 1 doom on this agenda for each Ghoul enemy in the Hallway or Parlor." }
  },
  ["01109"] = {
    [4] = { message = "The Act says: When the round ends, investigators in the hallway may, as a group, spend the requisite number of clues to advance." }
  },
  ["03048"] = {
    [4] = { message = "Act: Forced - At the end of the round: Place 1 horror on each location with no horror that is connected to a location with horror." }
  },

  ["03121"] = {
    [1] = { message = "Look if any of the cultists acts at the end of the Mythos phase" }
  },
  ["03122"] = {
    [1] = { message = "Look if any of the cultists acts at the end of the Mythos phase" }
  },
  ["03123"] = {
    [1] = { message = "Look if any of the cultists acts at the end of the Mythos phase" }
  },
  ["03045"] = {
    [3] = { message = "Emmissary:Forced - At the end of the enemy phase: Each investigator at Royal Emissary's location or a connecting location takes 1 horror." }
  }
}

local StartOfPhaseEffects = {
  ["01144"] = {
    [2] = { message = "Agenda:Each enemy gets +1 fight and +1 evade." }
  },
  ["03121"] = {
    [1] = { message = "Do not add doom to the doom counter" }
  },
  ["03122"] = {
    [1] = { message = "Do not add doom to the doom counter" }
  },
  ["03123"] = {
    [1] = { message = "Do not add doom to the doom counter" }
  },
  ["03063"] = {
    [3] = { message = "Dianne Forced - Forced - At the beginning of the enemy phase: Find the Bystander asset with the fewest clues on it. Move Dianne Devine to that asset's location, if able." }
  }
}

function broadcastEndOfPhaseEffects(id, phase, color)
  color = color or { r = 1, g = 1, b = 1 }
  --
  local pair_number_message = endOfPhaseEffects[id]
  if pair_number_message then
    local message = pair_number_message[phase]
    if message then
      broadcastToAll(message.message)
    end
  end
  return nil -- no encontrado
end

function broadcastStartOfPhaseEffects(id, phase, color)
  color = color or { r = 1, g = 1, b = 1 }
  --
  local pair_number_message = StartOfPhaseEffects[id]
  if pair_number_message then
    local message = pair_number_message[phase]
    if message then
      broadcastToAll(message.message)
    end
  end
  return nil -- no encontrado
end

-- Copied

function getDoomMetadata()
  -- This takes the metadata of the Agenda Card
  -- We use this to plot any kind of Phase effect of the Agenda Card
  -- Yet to implement the Act
  local agendaPos = MythosAreaApi.getAgendaPosition()
  local searchResult = SearchLib.atPosition(agendaPos, "isCardOrDeck")

  if #searchResult == 1 then
    local obj = searchResult[1]
    if obj.type == "Card" then
      return JSON.decode(obj.getGMNotes()) or {}
    else
      -- handle agenda deck
      local containedObjects = obj.getData().ContainedObjects
      local topCardData = containedObjects[#containedObjects]
      return JSON.decode(topCardData.GMNotes) or {}
    end
  end
  return {}
end

function getActMetadata()
  -- This takes the metadata of the ACT Card
  local actPos = MythosAreaApi.getActPosition()
  local searchResult = SearchLib.atPosition(actPos, "isCardOrDeck")

  if #searchResult == 1 then
    local obj = searchResult[1]
    if obj.type == "Card" then
      return JSON.decode(obj.getGMNotes()) or {}
    else
      -- handle deck
      local containedObjects = obj.getData().ContainedObjects
      local topCardData = containedObjects[#containedObjects]
      return JSON.decode(topCardData.GMNotes) or {}
    end
  end
  return {}
end



-- Aux

function size(container)
  local count = 0
  for _ in pairs(container) do count = count + 1 end
  return count 
end

function getPlayer(color)
  log('getPlayer called for color ' .. color)
  for _, pl in ipairs(Player.getPlayers()) do
    if pl.color == color then
      log('getPlayer found')
      return pl
    end
  end
  return nil
end


function getObjectByName(name)
  for _, obj in ipairs(getObjects()) do
    if obj.getName() == name then
      return obj
    end
  end
  return nil
end
